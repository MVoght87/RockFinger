
/*//////////////////////////////////////////////////////////////////////////////////////////////

PROJECT: ROCK FINGER 

1) Extracts Hand from User webcam and displays* number of fingers detected.
2) Show status of the hand as opened hand / closed hand

* Thumb is always indexed as 0.

This program is able to compute
- Center of Detected Hand
- Mass center of Detected Hand
- Rotation of Detected Hand
- Area of Detected Hand
- Orientation of Detected Hand ( facing down / facing up)
- Number of opened finger


*note*
there are two dots representing center of ROI, and center of mass.
for the best result, make sure they are actual near the center of the hand.


*WARNING*
-Algorithm uses motion detection. If Webcam has auto light adjustment feature,please disable it.
-Please make sure your webcam number is inputed correctly.

Created by Joel Richart, Michael Joe Voght, Allon Kim
Special Thanks To Dr.Olson @ UWB


*Credit / Reference *
please see attached Project documentation for details.


Last updated 6/3/2015

*//////////////////////////////////////////////////////////////////////////////////////////////

#include "opencv2/highgui/highgui.hpp"
#include "opencv2/imgproc/imgproc.hpp"
#include <opencv2/video/background_segm.hpp>
#include <opencv2/opencv.hpp>
#include <math.h> 
#include <cmath>
#include <iostream>
#include <algorithm>

using namespace cv;
using namespace std;

/////////////////////////////////////////////////////////////////////////////////////////////
// SYSTEM CONFIGURATION ////////////////////////////////////////////////////////////////////

const int CAM_NUMBER = 0;    // 0 for primary cam, 1 for additional cam


const bool PRINT_CAM_INFO = true;
const bool PRINT_NUM_DETECTION = true;

const bool DISPLAY_BINARY = true;
const bool DISPLAY_UNPROCESSED_BINARY = true;

const bool DISPLAY_CONTOUR = true;
const bool DISPLAY_FINGER = true;
const bool DISPLAY_FINGER_NUMBER = true;

const bool DISPLAY_ROI = true;
const bool DISPLAY_ROI_TIGHT_BOUND = true;
const bool DISPLAY_CENTER_MASS = true;

const bool RECORD_VIDEO = true;

//
//

///////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////





// Methods used in main ////////////////////////////////////////////////////////////////

Point getHandCenter(const Mat& mask, double& radius);
string intToString(int number);

static double angle(cv::Point pt1, cv::Point pt2, cv::Point pt0);
void setLabel(cv::Mat& im, const std::string label, std::vector<cv::Point>& contour);


///////////////////////////////////////////////////////////////////////////////////////




//global variables and mini objects ///////////////////////////////////////////////////

VideoWriter out;
const double PI = 3.141592653589793238463;

Mat fgMaskMOG2; // foreGround mask generated by MOG2 method

Ptr<BackgroundSubtractor> pMOG2; //MOG2 Background subtracter

vector<vector<Point>>contours;
vector<vector<Point>>contoursFiltered;
vector<Vec4i> hierarchy;
String status = "ROCK ON";

// This defines a binary predicate that, taking two values of the same type of those 
// contained in the list, returns true if the first argument goes before the second argument
struct myclass {
	bool operator() (cv::Point pt1, cv::Point pt2) { return (pt1.x < pt2.x); }
} xCompare;

struct myclass2 {
	bool operator() (cv::Point pt1, cv::Point pt2) { return (pt1.x > pt2.x); }
} xCompareReverse;

///////////////////////////////////////////////////////////////////////////////////////





int main(int argc, char* argv[])
{

	// initialize data   ///////////////////////////////////////////////////////////////
		
	// video input
	VideoCapture cap(CAM_NUMBER); // open the video camera 
	if (!cap.isOpened())  // if not success, exit program
	{
		cout << "Cannot open the video cam" << endl;
		return -1;
	}
	double dWidth = cap.get(CV_CAP_PROP_FRAME_WIDTH); //get the width of frames of the video
	double dHeight = cap.get(CV_CAP_PROP_FRAME_HEIGHT); //get the height of frames of the video

	if (PRINT_CAM_INFO) 
	cout << "Frame size : " << dWidth << " x " << dHeight << endl;
	
	namedWindow("MyVideo", CV_WINDOW_AUTOSIZE); //create a window called "MyVideo"

	out.open("out.avi", CV_FOURCC('M', 'J', 'P', 'G'), 15, Size(dWidth, dHeight), true);
	destroyWindow("MyVideo");
	
	//create Background Subtractor objects
	pMOG2 = new BackgroundSubtractorMOG2();

	
	Mat binary;  // binary 
	//Mat finalOut; // final processed output Mat
	
	long int frameNumber = 0;  // :)


	///////////////////////////////////////////////////////////////////////////////////////////////



	// Process data Readtime///////////////////////////////////////////////////////////////////////
	for (;;)     // keep reading / processing each frames.
	{

		frameNumber++; 

		////////////////////////////////////////////////////////////////////////////
		// step0. initialize 
		////////////////////////////////////////////////////////////////////////////
		
		// read a new frame from video
		Mat currentframe;
		Mat buffer;

		bool bSuccess = cap.read(currentframe);

		// guardian: if no video input, break.
		if (!bSuccess) 
		{
			cout << "Cannot read a frame from video stream" << endl;
			break;
		}
		
		// flip video so it mimics real life view
		cv::flip(currentframe, currentframe, 1);

		// always work with buffer. keep currentFrame as original reference.
		currentframe.copyTo(buffer);
		GaussianBlur(buffer, buffer, Size(1, 1), 0, 0);//applying Gaussian filter 
		//GaussianBlur(buffer, buffer, Size(7, 7), 0, 0);//applying Gaussian filter 
		
		// work with gray scale at the biginning  <- maybe not
		//cv::cvtColor(buffer, buffer, CV_BGR2GRAY);
		



		////////////////////////////////////////////////////////////////////////////
		// step 1. Create Binary using MOG2
		////////////////////////////////////////////////////////////////////////////

		pMOG2->operator()(buffer, fgMaskMOG2,0);  // learning rate-> 0 foreign body at the start, -1: normal 
		
		if (DISPLAY_UNPROCESSED_BINARY)
		imshow("Binary-Unprocessed", fgMaskMOG2);


		////////////////////////////////////////////////////////////////////////////
		// step 2. remove noise and produce processed Binary.
		////////////////////////////////////////////////////////////////////////////
		
		// call MOG2 !
		binary = fgMaskMOG2;

		
		// logitech WebCam setting.
		int niters = 2;//num of repeat    
		erode(binary, binary, Mat(), Point(-1, -1), niters * 2);//EROE!  
		dilate(binary, binary, Mat(), Point(-1, -1), niters * 2);// DILATE!
		threshold(binary, binary, 250, 256, CV_THRESH_BINARY);// delete grays


		// apple webcam
		//int niters =2;//num of repeat     
		//dilate(binary, binary, Mat(), Point(-1, -1), niters );  
		//erode(binary, binary, Mat(), Point(-1, -1), niters * 2);  
		//dilate(binary, binary, Mat(), Point(-1, -1), niters);
		//threshold(binary, binary, 250, 256, CV_THRESH_BINARY);

		// Joel's webcam
		//int niters = 2;//num of repeat    
		//dilate(binary, binary, Mat(), Point(-1, -1), niters*1);
		//erode(binary, binary, Mat(), Point(-1, -1), niters * 2);//EROE!  
		//dilate(binary, binary, Mat(), Point(-1, -1), niters * 1);// DILATE!
		//threshold(binary, binary, 150, 256, CV_THRESH_BINARY);// delete grays

		if (DISPLAY_BINARY)
		imshow("binary-processed", binary);



		////////////////////////////////////////////////////////////////////////////
		// step 3. from processed binary, extract contour.
		//         each contours are seved in vector named countours
		////////////////////////////////////////////////////////////////////////////


		// CV_RETR_TREE +  hierarchy
		cv::findContours(binary, contours, hierarchy, CV_RETR_TREE, CV_CHAIN_APPROX_SIMPLE);


		// CV_RETR_EXTERNAL  // orignal method.
		//cv::findContours(binary , contours, CV_RETR_EXTERNAL, CV_CHAIN_APPROX_NONE);   

		// CV_RETR_EXTERNAL +  hierarchy (optional)
		//cv::findContours(binary , contours, hierarchy, CV_RETR_EXTERNAL, CV_CHAIN_APPROX_NONE);
		
		// CV_RETR_CCOMP +  hierarchy
		//findContours( binary , contours, hierarchy, CV_RETR_CCOMP, CV_CHAIN_APPROX_SIMPLE );



		////////////////////////////////////////////////////////////////////////////
		// step 4. go through contours in vector contours, and filter out no good contours.
		////////////////////////////////////////////////////////////////////////////
		
		// should i just find the biggest contour??? -> lets test it.
		// if we want to use distanceTransform(), we have to. so Yes.
		
		double maxSizeSoFar = -1;
		int minSizeLimit = 5000;
		int maxSizeLimit = 80000;

		
		for (int i = 0; i < contours.size(); i++)  // check all contours saved in contour vector,
		{

			// filter condition1: hierarchy
			// since we are looking for most outer contour, the parent contour is not -1, then it is no good.
			// hierarchy[idx][{0,1,2,3}]={next contour (same level), previous contour (same level), child contour, parent contour}
			// if parent contour != -1 , it is not the most outer contour.

			if (hierarchy[i][3] > 0)
			{
				continue;
			}

			// filter condition2 : size
			// if size of contour is out of minSize, and max Size, it is no good contour. move on to next contour
			double contourSize = contourArea(contours[i], false);
			if (contourSize <= minSizeLimit)
			{
				continue;
			}
			if (contourSize >= maxSizeLimit)
			{
				continue;
			}
			

			// from there, only keep the longest contour in contoursFiltered.
			if ((contourSize >= maxSizeSoFar) )
			{
				if (contoursFiltered.size() != 0)	contoursFiltered.pop_back();
				contoursFiltered.push_back(contours.at(i));

			}
			
		}
		


		////////////////////////////////////////////////////////////////////////////
		// step 5. process and draw filtered contours
		////////////////////////////////////////////////////////////////////////////
		
		// -> at this point, we have one contour and it is the biggest.
		int numOfContours = contoursFiltered.size();
		

		/// vector for  moments
		vector<Moments> mu(contoursFiltered.size());
		
		/// vector for  mass centers
		vector<Point2f> mc(contoursFiltered.size());

		CvSeq* result;   //hold sequence of points of a contour
		CvMemStorage *storage = cvCreateMemStorage(0); //storage area for all contours
		//CvSeq* contoursP;  //hold the pointer to a contour in the memory block

		if (PRINT_NUM_DETECTION)
		cout <<"Num of Detections= " << numOfContours << endl;

		
		//coordinates of ROI made out of biggest contour.
		// used later for filtering purpose. bigger Y mean it is toward the bottom of the screen.
		int roi_x_left = dWidth;
		int roi_x_right = 0;
		int roi_y_top = dHeight;
		int roi_y_bot = 0;
		int roi_x_center = -1;
		int roi_y_center = -1;


		// draw ROI rectangle and tight bounded rectangle
		for (int i = 0; i<numOfContours; i++) {
			
			// regular roi rectangel
			rectangle(currentframe, boundingRect(contoursFiltered[i]), Scalar(0, 255, 0), 1, 8, 0);
						
			int roi_width = boundingRect(contoursFiltered[0]).width;
			int roi_height = boundingRect(contoursFiltered[0]).height;

			roi_x_left = boundingRect(contoursFiltered[i]).x;
			roi_x_right = roi_x_left + roi_width;
			roi_y_top = boundingRect(contoursFiltered[i]).y;
			roi_y_bot = roi_y_top + roi_height;
			roi_x_center = roi_x_left + roi_width / 2;;
			roi_y_center = roi_y_top + roi_height / 2;
			
			if (DISPLAY_ROI)
			{
				circle(currentframe, Point(roi_x_left, roi_y_top), 3, Scalar(0, 0, 0), -1);
				circle(currentframe, Point(roi_x_right, roi_y_top), 3, Scalar(0, 0, 0), -1);
				circle(currentframe, Point(roi_x_left, roi_y_bot), 3, Scalar(0, 0, 0), -1);
				circle(currentframe, Point(roi_x_right, roi_y_bot), 3, Scalar(0, 0, 0), -1);
				circle(currentframe, Point(roi_x_center, roi_y_center), 3, Scalar(0, 0, 0), -1);
			}
			
			/// Get the moments
			mu[i] = moments(contoursFiltered[i], false);

			///  Get the mass centers:
			mc[i] = Point2f(mu[i].m10 / mu[i].m00, mu[i].m01 / mu[i].m00);

			// draw mass centers
			circle(currentframe, mc[i], 4, Scalar(0, 255, 0), -1, 8, 0);
			

			// within the contour, since now we now the mass center. remove those 'arm area'
			// actually, tested  result said this is better done after getting vertex.
			for (int j = 0; j < contoursFiltered[i].size(); j++)
			{
				if (contoursFiltered[i].at(j).y >((mc[i].y + roi_y_bot)/2))
				{
					contoursFiltered[i].at(j).y = ((mc[i].y + roi_y_bot) / 2);
					contoursFiltered[i].at(j).x = contoursFiltered[i].at(j - 1).x;
				}
			}


			// draw contours
			if (DISPLAY_CONTOUR)
			cv::drawContours(currentframe, contoursFiltered, i, cv::Scalar(0, 0, 255), 2);   // last -1: fill inside

			
			// rotated rectangle
			vector<RotatedRect> minRect(numOfContours);
			for (int i = 0; i < contoursFiltered.size(); i++)
			{
				minRect[i] = minAreaRect(Mat(contoursFiltered[i]));
			}

			Point2f rect_points[4]; minRect[i].points(rect_points);
			for (int j = 0; j < 4; j++){

				if (DISPLAY_ROI_TIGHT_BOUND)
				line(currentframe, rect_points[j], rect_points[(j + 1) % 4], Scalar(0, 255, 255), 1, 8);
			}


			
			}


		// step 5.1 within the contour, find the most dominant colore, and filter out contour area one more time.  // if possible
		// we do not need this.


		

		////////////////////////////////////////////////////////////////////////////
		// step 6. get fingers
		////////////////////////////////////////////////////////////////////////////

		//method1: FAIL do distanceTransform to get the center of only hand.
		//double radius;
		//Point center = getHandCenter(binary, radius);
		//circle(currentframe, center, 6, Scalar(0, 255, 0), -1);
		///circle(currentframe, center, (int)(radius + float(radius*0.30)), Scalar(255, 0, 0), 2);
		
		
		// 6-1. Loop through all the contours and get the approximate polygonal curves for each contour,


		// The vector for storing the approximation curve
		std::vector<cv::Point> approx;
		for (int i = 0; i < contoursFiltered.size(); i++)
		{
			// Approximate contour with accuracy proportional
			// to the contour perimeter
			cv::approxPolyDP(
				cv::Mat(contoursFiltered[i]),
				approx,
				cv::arcLength(cv::Mat(contoursFiltered[i]), true) * 0.02,
				true
				);
		}
				


		// vector approx has all the vertex


		// 6-2. Filter out the bad vertex, and re-order them in accordingly from left to right.

		
		// within the vertices, since now we know the mass center. ignore those 'arm area'
		for (int i = 0; i < approx.size(); i++)
		{
			if (approx.at(i).y > mc[0].y)
			{
				std::swap(approx.at(i), approx.back());
				approx.pop_back();
			}
		}		

		
		// find the length between end of each finger tips and center of mass
		vector <double> fingerLength;
		double averageFingerLength = 0;
		//double averageDifferences = 0.0;

		for (int i = 0; i < approx.size(); i++)
		{
			cv::Point a(approx.at(i).x, approx.at(i).y);
			cv::Point b(mc[0].x, mc[0].y);
			double res = cv::norm(a - b);//Euclidian distance
			//cout << "res= " << res << endl;
			fingerLength.push_back(res);
			averageFingerLength += res;
			
		}

		averageFingerLength = averageFingerLength / fingerLength.size();
		//cout << "averageFingerLength= " << averageFingerLength << endl;

		if (approx.size() != 0)
		circle(currentframe, Point(mc[0].x, mc[0].y), averageFingerLength, Scalar(0, 0, 0), 1);


		// get the indicator where the thumb is. 
		// compare the first web, and the last web, and the shorter side is the thumb web( always)

		double dist_FristWeb = 0;
		double dist_LastWeb = 0;
		bool thumbRight = true;

		if (approx.size() > 1){

			cv::Point FW_Top(approx.at(1).x, approx.at(1).y);
			cv::Point LW_Top(approx.at(approx.size() - 2).x, approx.at(approx.size() - 2).y);
			cv::Point b(mc[0].x, mc[0].y);
			dist_FristWeb = cv::norm(FW_Top - b);//Euclidian distance
			dist_LastWeb = cv::norm(LW_Top - b);

			if (dist_FristWeb <= dist_LastWeb) thumbRight = false;
		}


		// using average finger length; weed out the non- fingers (webbing area)
		if (approx.size() > 1){
			for (int i = 0; i < approx.size() - 1; i++)
			{
				if (fingerLength.at(i) < (1.2)*averageFingerLength)
				{
					//cout << "short" << endl;
					fingerLength.erase(fingerLength.begin() + i);
					approx.erase(approx.begin() + i);
	
				}

			}
		}
		
		// sort them so the 0 always follows thumb
		
		if (!thumbRight)   // thumb on left
		{
			std::sort(approx.begin(), approx.end(), xCompare);
		}
		else  // thumb on right
		{
			std::sort(approx.begin(), approx.end(), xCompareReverse);
		}
				

		// get degree of the hand using the two lines. 
		// 1)ROI bot line   2) line between longest finger(middle) center of mass
		if (approx.size() != 0)
		{
			if ((approx.size() > 1))
			{
				
				float x1 = float(mc[0].x);
				float y1 = float(mc[0].y);
				int middleIndex = approx.size() / 2;
				float x2 = float(approx[middleIndex].x);
				float y2 = float(approx[middleIndex].y);
				
				int angle = int(atan((y1 - y2) / (x2 - x1)) * 180 / PI);
				//cout << "angle = " << angle << endl;
				stringstream ss1;
				string angleString = ss1.str();
				putText(currentframe, angleString.c_str(), Point(int(x1), (int(y2) + int(y1)) / 2),
					FONT_HERSHEY_SIMPLEX, 5, cv::Scalar(0, 0, 0), 3);

			}
		}
		



		// print all (filtered vertex)

		if (DISPLAY_FINGER)
		for (int i = 0; i < approx.size(); i++)
		{
			circle(currentframe, approx.at(i), 5, Scalar(232, 162, 0), -1);
			String index = intToString(i);

			if (DISPLAY_FINGER_NUMBER)
			putText(currentframe, index.c_str(), approx.at(i),
				FONT_HERSHEY_SIMPLEX, 1.0, cv::Scalar(0, 0, 0), 3);
	
		}


		// update status of hand ( open closed / closed hand)
		if (approx.size() >= 5)
		{
			status = "Opened";   // at least 5 fingers are shown)
		}
		else
		{
			status = "Closed";
		}




		// arch approach for feeding out bad vertex. got it from net.  not working great. 
		/*
		for (int i = 0; i < contoursFiltered.size(); i++)
		{
			// Approximate contour with accuracy proportional
			// to the contour perimeter
			cv::approxPolyDP(
				cv::Mat(contoursFiltered[i]),
				approx,
				cv::arcLength(cv::Mat(contoursFiltered[i]), true) * 0.02,
				true
				);

			// Skip small or non-convex objects 
			//if (std::fabs(cv::contourArea(contours[i])) < 100 || !cv::isContourConvex(approx))
			//	continue;

			if (approx.size() == 3)
				setLabel(currentframe, "TRI", contours[i]);    // Triangles // Triangles

			else if (approx.size() >= 4)
			{
				// Number of vertices of polygonal curve
				int vtc = approx.size();
				cout <<vtc << endl;
				// Get the degree (in cosines) of all corners
				std::vector<double> cos;
				for (int j = 2; j < vtc + 1; j++)
					cos.push_back(angle(approx[j%vtc], approx[j - 2], approx[j - 1]));

				// Sort ascending the corner degree values
				std::sort(cos.begin(), cos.end());

				// Get the lowest and the highest degree
				double mincos = cos.front();
				double maxcos = cos.back();

				// Use the degrees obtained above and the number of vertices
				// to determine the shape of the contour
				if (vtc == 4 && mincos >= -0.1 && maxcos <= 0.3)
				{
					// Detect rectangle or square
					cv::Rect r = cv::boundingRect(contours[i]);
					double ratio = std::abs(1 - (double)r.width / r.height);

					setLabel(currentframe, ratio <= 0.02 ? "SQU" : "RECT", contours[i]);
				}
				else if (vtc == 5 && mincos >= -0.34 && maxcos <= -0.27)
					setLabel(currentframe, "PENTA", contours[i]);
				else if (vtc == 6 && mincos >= -0.55 && maxcos <= -0.45)
					setLabel(currentframe, "HEXA", contours[i]);
			}
		}
		*/

		
		contoursFiltered.clear();
		contours.clear();
	

		

		
		//OUTPUT DISPLAY///////////////////////////////////////////////////////////////////
				
		// make place holder for hand status display
		stringstream ss;
		rectangle(currentframe, cv::Point(10, 2), cv::Point(200, 50),
		cv::Scalar(255, 255, 255), -1);
		
		string frameNumberString = ss.str();
		//string test =  "ROCK ON";
		putText(currentframe, status.c_str(), cv::Point(20, 40),
			FONT_HERSHEY_SIMPLEX, 1.0, cv::Scalar(0, 0, 0),3);


		// output final Mats
		imshow("MyVideo", currentframe); //show the currentframe in "MyVideo" window
		//imshow("Binary", binary); //show the binary in "MyVideo" window

		//video save
		if (RECORD_VIDEO)
		out << currentframe;

		// esc to exit program.
		if (waitKey(30) == 27) //wait for 'esc' key press for 30ms. If 'esc' key is pressed, break loop
		{
			cout << "esc key is pressed by user" << endl;
			break;
		}
		if (waitKey(30) == 'r')
		{
			cout << "Rock On" << endl;
		}


	}  // end of main for-loop

	return 0;


}



///////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////



/**
* Helper function to find a typecast int to string.
*/
string intToString(int number){
	stringstream ss;
	ss << number;
	string str = ss.str();
	return str;
}




// fail. do not use it. Not stable.
Point getHandCenter(const Mat& mask, double& radius){


	Mat dst;
		distanceTransform(mask, dst, CV_DIST_L2, 5);  

	int maxIdx[2];  
	minMaxIdx(dst, NULL, &radius, NULL, maxIdx, mask);   


	return Point(maxIdx[1], maxIdx[0]);

}



/**
* Helper function to find a cosine of angle between vectors
* from pt0->pt1 and pt0->pt2
*/
static double angle(cv::Point pt1, cv::Point pt2, cv::Point pt0)
{
	double dx1 = pt1.x - pt0.x;
	double dy1 = pt1.y - pt0.y;
	double dx2 = pt2.x - pt0.x;
	double dy2 = pt2.y - pt0.y;
	return (dx1*dx2 + dy1*dy2) / sqrt((dx1*dx1 + dy1*dy1)*(dx2*dx2 + dy2*dy2) + 1e-10);
}

/**
* Helper function to display text in the center of a contour
*/
void setLabel(cv::Mat& im, const std::string label, std::vector<cv::Point>& contour)
{
	int fontface = cv::FONT_HERSHEY_SIMPLEX;
	double scale = 0.4;
	int thickness = 1;
	int baseline = 0;

	cv::Size text = cv::getTextSize(label, fontface, scale, thickness, &baseline);
	cv::Rect r = cv::boundingRect(contour);

	cv::Point pt(r.x + ((r.width - text.width) / 2), r.y + ((r.height + text.height) / 2));
	cv::rectangle(im, pt + cv::Point(0, baseline), pt + cv::Point(text.width, -text.height), CV_RGB(255, 255, 255), CV_FILLED);
	cv::putText(im, label, pt, fontface, scale, CV_RGB(0, 0, 0), thickness, 8);
}

